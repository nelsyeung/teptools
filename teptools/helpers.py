"""Teptools helpers."""
import configparser
import glob
import os
import re


def parse_rcfile(rcfile, section, default):
    """Return the specified section configurations from users rc file."""
    if rcfile is None:
        rcfile = os.path.join(os.path.expanduser('~'), '.teptoolsrc')

    if not os.path.isfile(rcfile):
        return default

    parser = configparser.ConfigParser()
    parser.read(rcfile)
    config = dict(default)

    if section not in parser:
        parser[section] = {}

    # Use the settings from [DEFAULT] when they don't exist within [section]
    # If the settings don't exist in [DEFAULT] then use the ones in default
    for setting in default:
        config[setting] = parser[section].get(setting, default[setting])

        if type(default[setting]) is list:
            config[setting] = [l.strip()
                               for l in config[setting].split(',')]

    return config


def parse_inpfile(inpfile):
    """Return the keywords and blocks from a ONETEP input file."""
    block = False
    config = {
        'keywords': {},
        'blocks': {}
    }

    if not os.path.isfile(inpfile):
        return {}

    with open(inpfile, 'r') as f:
        for line in f:
            raw_line = line.strip()
            line = raw_line.lower()
            linesplit = line.split()

            # Ignore comments and empty lines
            if (not line or
                    line.startswith('#') or
                    line.startswith(';') or
                    line.startswith('!')):
                continue

            # Start of a block
            if not block and line.startswith('%block '):
                block = line.split()[1].lower()
                config['blocks'][block] = []
                continue

            # End of a block regardless of the name
            if block and line.startswith('%endblock'):
                block = False
                continue

            # Parse config outside of a block
            if not block:
                key = False

                if len(linesplit) == 2:
                    key = linesplit[0]
                    value = linesplit[1]
                elif len(linesplit) > 2:
                    key = linesplit[0]
                    value = linesplit[1]

                    # Ignore key value separator
                    regex = re.compile('^[0-9a-zA-Z.]*$')

                    if not regex.match(value):
                        value = linesplit[2]

                if key:
                    config['keywords'][key] = value

            # If inside a block store every line
            if block:
                config['blocks'][block].append(raw_line)

    return config


def find_files(args, ext):
    """Return a list of files with the specified extension from arguments.

    Keyword arguments:
    args -- a list of patterns arguments passed by the user
    ext  -- extension of the file for globbing

    Return:
    files -- a list of 'useful' files based on the following rules:
    - If a file is not specified, get all *.{ext} files
    - If an argument includes '*' (glob pattern), expand the glob pattern
    - If the list of files includes directory, get all *.{ext} files within
      that directory.
    - Exclude any files generated by HPC
    - Exclude any files with an extension that is obviously not an file
    """
    # If a file is not specified, get all *.{ext} files
    if len(args) == 0:
        args = ['*.' + ext]

    # Provide globbing for arguments
    files = []
    for file in args:
        if '*' in file:
            files.extend(glob.glob(file))
        else:
            files.append(file)

    # If arguments contains directories, get all *.{ext} from the directories
    i = 0
    while i < len(files):
        if os.path.isdir(files[i]):
            globbed = glob.glob(os.path.join(files[i], '*.' + ext))
            del files[i]
            files[i:i] = globbed
            i += len(globbed)
        else:
            i += 1

    # Exclude any files generated by HPC
    # Exclude any files with extension as one of the programming languages
    excluded_names = ['slurm', 'pbs']
    excluded_ext = ['py', 'sh', 'f90', 'c', 'cpp']
    i = 0
    while i < len(files):
        if (any(files[i].endswith('.' + ext) for ext in excluded_ext) or
                any(name in files[i] for name in excluded_names)):
            del files[i]
        else:
            i += 1

    return files


def create_file(name, ext):
    """Create a new file from a file name. If a file with the same name already
    exists, it will suffix the file name with a new number."""
    index = 0

    while True:
        if index == 0:
            newfile = name + '.' + ext
        else:
            newfile = name + '_' + str(index) + '.' + ext

        if not os.path.isfile(newfile):
            return newfile, open(newfile, 'a')
        else:
            index += 1
